#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import discord
from discord import app_commands
import asyncio
import os
import websocket # Ensure 'websocket-client' library is installed (`pip install websocket-client`)
import time
import re
import json
from collections import defaultdict
import traceback # For better error logging
from typing import Dict, Tuple, List # For type hinting

# --- Configuration ---
# Retrieve the bot token from environment variables for security
TOKEN = os.getenv("DISCORD_TOKEN")

# --- Helper Functions ---
def log(message):
    """Simple timestamped logging to console."""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")

# --- NEW: Helper function for formatting rewards ---
def format_rewards_field_value(rewards: Dict[str, int]) -> str:
    """
    Formats the rewards dictionary into a string for the Discord embed field,
    applying emoji mapping and custom sorting.
    """
    if not rewards:
        return "Keine Belohnungen vorhanden."

    direct_emoji_map = {
        "Werkzeuge": "<:tools:1359522120509554922>",
        "Ausr√ºstung/Edelsteine": "<:gear:1359518850713911488>",
        "Konstrukte": "<:konstrukte:1359518720531235047>",
        "Kisten": "<:chest:1359518414154104974>",
        "Dekorationen": "<:dekorationen:1359518108900917359>",
        "Mehrweller": "<:mehrweller:1359517882064699483>",
        "Sceattas": "<:sceatta:1359517377066438747>",
        "Beatrice-Geschenke": "<:beatrice:1359517272640721170>",
        "Ulrich-Geschenke": "<:ulrich:1359516848474820789>",
        "Ludwig-Geschenke": "<:ludwig:1359516694716092416>",
        "Baumarken": "<:baumarken:1359516243463373030>",
        "Ausbaumarken": "<:ausbaumarken:1359516063477268622>",
        "Rubine": "<:ruby:1359515929951731812>",
        "Lose": "<:ticket:1359508197429219501>",
        "Besch√ºtzer des Nordens": "<:beschuetzer:1359481568430915765>",
        "Schildmaid": "<:schildmaid:1359479372041683015>",
        "Walk√ºren-Scharfsch√ºtzin": "<:scharfschuetzin:1359477765421793422>",
        "Walk√ºren-Waldl√§uferin": "<:waldlaeuferin:1359477735856013576>"
    }

    # 2. Define sort order priorities
    sort_priority = {
        "Schildmaid": 0, "Walk√ºren-Scharfsch√ºtzin": 0, "Besch√ºtzer des Nordens": 0, "Walk√ºren-Waldl√§uferin": 0, # Troops
        "Lose": 1, # Tickets
        "Rubine": 2, # Rubies
        "Ludwig-Geschenke": 3, "Ulrich-Geschenke": 3, "Beatrice-Geschenke": 3, # Lord Gifts
    }
    DEFAULT_PRIORITY = 99

    # 3. Define the sort key function
    def get_reward_sort_key(item: Tuple[str, int]):
        key, _ = item
        priority = sort_priority.get(key, DEFAULT_PRIORITY)
        return (priority, key)

    # 4. Sort the rewards
    try:
        sorted_rewards = sorted(rewards.items(), key=get_reward_sort_key)
    except Exception as e:
        log(f"Fehler beim Sortieren der Belohnungen: {e}")
        # Fallback to basic alphabetical sort if custom sort fails
        sorted_rewards = sorted(rewards.items())


    # 5. Format the sorted rewards
    reward_lines_list = []
    for reward_key, reward_value in sorted_rewards:
        emoji_string = direct_emoji_map.get(reward_key)
        if emoji_string:
            reward_lines_list.append(f"{emoji_string} {reward_value:,}")
        else:
            # Log only if it was an expected key but emoji is missing from map (unlikely now)
            # Or if it's a truly unknown key generated by the parser
            if not reward_key.startswith("Unbekannt_"):
                 log(f"‚ÑπÔ∏è Kein direkter Emoji-String f√ºr '{reward_key}' in der Map gefunden. Zeige Namen an.")
            reward_lines_list.append(f"**{reward_key}**: {reward_value:,}")

    return "\n".join(reward_lines_list)
# --- END of new helper function ---


# --- Discord UI Modal for Input ---
class SpinModal(discord.ui.Modal, title="üé∞ SpinBot Eingabe"):
    """A Discord Modal (form) to collect user credentials and spin count."""
    def __init__(self):
        super().__init__(timeout=300) # 5-minute timeout for the modal
        self.username = discord.ui.TextInput(label="Benutzername", placeholder="Gib deinen Empire-Benutzernamen ein...", required=True, style=discord.TextStyle.short, max_length=50)
        self.password = discord.ui.TextInput(label="Passwort", placeholder="Gib dein Passwort ein...", style=discord.TextStyle.short, required=True, max_length=50)
        self.spins = discord.ui.TextInput(label="Anzahl der Spins", placeholder="Wie oft soll das Rad gedreht werden?", style=discord.TextStyle.short, required=True, max_length=4)
        self.add_item(self.username)
        self.add_item(self.password)
        self.add_item(self.spins)

    # --- MODIFIED on_submit to use helper function ---
    async def on_submit(self, interaction: discord.Interaction):
        """Handles the modal submission."""
        username = self.username.value
        password = self.password.value
        try:
            spins = int(self.spins.value)
            if not (1 <= spins <= 1000): raise ValueError("Spin count out of range.")
        except ValueError:
            await interaction.response.send_message("‚ùå Ung√ºltige Anzahl an Spins. Bitte gib eine Zahl (z.B. zwischen 1 und 1000) ein.", ephemeral=True); return

        await interaction.response.send_message("üîí Deine Eingaben wurden sicher verarbeitet! Starte Spins...", ephemeral=True)
        embed = discord.Embed(title="üé∞ SpinBot wird gestartet!", description=f"Initialisiere `{spins}` Spin(s) f√ºr den Benutzer `{username}`...\n*Dies kann einen Moment dauern.*", color=discord.Color.orange())
        embed.set_footer(text="Bitte habe Geduld, bis alle Spins abgeschlossen sind.")
        status_message = await interaction.followup.send(embed=embed, wait=True)

        try:
            rewards = await asyncio.to_thread(spin_lucky_wheel, username, password, spins)
            embed_done = discord.Embed(title="‚úÖ Spins Abgeschlossen!", description=f"Alle `{spins}` Spins f√ºr `{username}` wurden ausgef√ºhrt.", color=discord.Color.green())

            if rewards:
                # --- Use the helper function to format rewards ---
                reward_lines = format_rewards_field_value(rewards)
                embed_done.add_field(name="üéÅ Erhaltene Belohnungen", value=reward_lines, inline=False)
                # --- End of using helper function ---
            else:
                embed_done.add_field(name="üéÅ Erhaltene Belohnungen", value="Keine Belohnungen erkannt oder Prozess vorzeitig beendet.", inline=False)
                embed_done.color = discord.Color.gold()

            await status_message.edit(embed=embed_done)
        except Exception as e:
            print(f"Error during spin_lucky_wheel execution for {username}: {e}"); traceback.print_exc()
            embed_error = discord.Embed(title="‚ùå Fehler beim Ausf√ºhren der Spins!", description=f"Ein Problem ist w√§hrend der Verarbeitung der Spins f√ºr `{username}` aufgetreten.\n M\u00f6gliche Gr\u00fcnde: Falsche Login-Daten, Serverprobleme, Netzwerkunterbrechung.\n Bitte \u00fcberpr\u00fcfe die Konsolenlogs des Bots f\u00fcr Details.", color=discord.Color.red())
            await status_message.edit(embed=embed_error)

    async def on_error(self, interaction: discord.Interaction, error: Exception) -> None:
        print(f"Error in SpinModal interaction: {error}"); traceback.print_exc()
        resp_func = interaction.followup.send if interaction.response.is_done() else interaction.response.send_message
        await resp_func('Hoppla! Etwas ist beim √ñffnen des Formulars schiefgelaufen.', ephemeral=True)

# --- Discord Bot Class (Simplified setup_hook) ---
class SpinBot(discord.Client):
    """The main Discord bot client."""
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = False
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)

    async def setup_hook(self):
        """Syncs commands before the bot is ready."""
        log("üîå Running setup_hook...")
        log("   Syncing slash commands...")
        try:
            await self.tree.sync()
            log("‚úÖ Slash-Befehle synchronisiert.")
        except Exception as e:
            log(f"   ‚ùå Error syncing commands in setup_hook: {e}")
            traceback.print_exc()
        log("‚úÖ setup_hook complete.")

    async def on_ready(self):
        """Called when the bot successfully connects to Discord."""
        print(f"‚úÖ Bot ist online als {self.user} (ID: {self.user.id})")
        print(f"‚úÖ Bereit und wartet auf Befehle...")


# --- MODIFIED parse_reward_message to handle LT as Baumarken ---
def parse_reward_message(msg, rewards):
    """Parses the specific reward message format from the game server."""
    try:
        match = re.search(r"%xt%lws%1%0%(.*)%", msg)
        if not match:
            if msg.startswith("%xt%"): pass
            return
        json_str = match.group(1)
        data = json.loads(json_str)
        if "R" not in data or not isinstance(data["R"], list):
            log(f"‚ÑπÔ∏è Keine g√ºltige 'R' (Rewards) Liste im geparsten JSON gefunden: {data}")
            return
        for item in data["R"]:
            if not isinstance(item, list) or len(item) < 2:
                log(f"  ‚ö†Ô∏è √úberspringe ung√ºltiges Belohnungsitem-Format: {item}")
                continue
            reward_type = item[0]; reward_data = item[1]; amount = 0; reward_name = None
            try: # Simplified Reward Type Handling
                if reward_type == "U":
                    if isinstance(reward_data, list) and len(reward_data) == 2: unit_id, amount = reward_data; truppen_namen = { 215: "Schildmaid", 238: "Walk√ºren-Scharfsch√ºtzin", 227: "Besch√ºtzer des Nordens", 216: "Walk√ºren-Waldl√§uferin" }; reward_name = truppen_namen.get(unit_id, "Werkzeuge")
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'U': {reward_data}")
                elif reward_type == "RI": amount = 1; reward_name = "Ausr√ºstung/Edelsteine"
                elif reward_type == "CI": amount = 1; reward_name = "Konstrukte"
                elif reward_type == "LM": # This is Ausbaumarken
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Ausbaumarken"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'LM': {reward_data}")
                elif reward_type == "LT": # This is Baumarken
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Baumarken"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'LT': {reward_data}")
                elif reward_type == "STP":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Sceattas"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'STP': {reward_data}")
                elif reward_type == "SLWT":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Lose"
                    else: amount = 1; log(f"  ‚ö†Ô∏è Ung√ºltiges/Kein Mengenformat f√ºr Typ 'SLWT', nehme 1 an: {reward_data}"); reward_name = "Lose"
                elif reward_type == "LB":
                    if isinstance(reward_data, list) and len(reward_data) > 1 and isinstance(reward_data[1], int): amount = reward_data[1]; reward_name = "Kisten"
                    elif isinstance(reward_data, int): amount = reward_data; reward_name = "Kisten"
                    else: amount = 1; log(f"  ‚ö†Ô∏è Ungew√∂hnliches Format f√ºr Typ 'LB', nehme Menge 1 an: {reward_data}"); reward_name = "Kisten"
                elif reward_type == "UE": amount = 1; reward_name = "Mehrweller"
                elif reward_type == "C2":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Rubine"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'C2': {reward_data}")
                elif reward_type == "FKT":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Ludwig-Geschenke"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'FKT': {reward_data}")
                elif reward_type == "PTK":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Beatrice-Geschenke"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'PTK': {reward_data}")
                elif reward_type == "KTK":
                    if isinstance(reward_data, int): amount = reward_data; reward_name = "Ulrich-Geschenke"
                    else: log(f"  ‚ö†Ô∏è Ung√ºltiges Format f√ºr Typ 'KTK': {reward_data}")
                elif reward_type == "D": amount = 1; reward_name = "Dekorationen"
                else: # Handle truly unknown types
                    if isinstance(reward_data, int): amount = reward_data
                    elif isinstance(reward_data, list) and len(reward_data) > 1 and isinstance(reward_data[1], int): amount = reward_data[1]
                    else: amount = 1
                    reward_name = f"Unbekannt_{reward_type}"; log(f"  -> Unbekannter Belohnungstyp: {reward_type} mit Daten {reward_data}. Gez√§hlt als '{reward_name}'.")
                if reward_name and amount > 0: rewards[reward_name] += amount
            except Exception as parse_inner_err: log(f"  ‚ùå Fehler beim Verarbeiten des Items {item}: {parse_inner_err}"); traceback.print_exc(limit=1)
    except json.JSONDecodeError as e: log(f"‚ùå Fehler beim JSON-Parsen des extrahierten Strings '{json_str}': {e}")
    except Exception as e: log(f"‚ùå Unerwarteter Fehler beim Parsen der Nachricht '{msg[:100]}...': {e}"); traceback.print_exc()


# --- Core WebSocket Logic ---
def spin_lucky_wheel(username, password, spins):
    # This function remains unchanged
    rewards = defaultdict(int); ws = None; connect_timeout = 20.0; login_wait_time = 5.0; receive_timeout_per_spin = 15.0; spin_send_delay = 0.3
    try:
        log(f"Versuche Verbindung herzustellen (Timeout: {connect_timeout}s)")
        ws = websocket.create_connection("wss://ep-live-de1-game.goodgamestudios.com/", timeout=connect_timeout)
        log("‚úÖ WebSocket-Verbindung erfolgreich hergestellt!")
        log("Sende Login-Sequenz...")
        ws.send("<msg t='sys'><body action='verChk' r='0'><ver v='166' /></body></msg>"); time.sleep(0.1)
        ws.send("<msg t='sys'><body action='login' r='0'><login z='EmpireEx_2'><nick><![CDATA[]]></nick><pword><![CDATA[1119057%de%0]]></pword></login></body></msg>"); time.sleep(0.1)
        ws.send(f"%xt%EmpireEx_2%vln%1%{{\"NOM\":\"{username}\"}}%"); time.sleep(0.1)
        login_command = f"%xt%EmpireEx_2%lli%1%{{\"CONM\":491,\"RTM\":74,\"ID\":0,\"PL\":1,\"NOM\":\"{username}\",\"PW\":\"{password}\",\"LT\":null,\"LANG\":\"de\",\"DID\":\"0\",\"AID\":\"1735403904264644306\",\"KID\":\"\",\"REF\":\"https://empire-html5.goodgamestudios.com\",\"GCI\":\"\",\"SID\":9,\"PLFID\":1}}%"
        ws.send(login_command); log(f"üîê Anmeldeversuch f√ºr '{username}' gesendet.")
        log(f"‚è≥ Warte {login_wait_time} Sekunden nach dem Login-Versuch..."); time.sleep(login_wait_time)
        try: # Clear buffer
            ws.settimeout(0.1);
            while True: msg = ws.recv()
        except (websocket.WebSocketTimeoutException, TimeoutError): pass
        except Exception as discard_err: log(f"‚ö†Ô∏è Fehler beim Verwerfen alter Nachrichten nach Login: {discard_err}")
        ws.settimeout(receive_timeout_per_spin)
        log("üöÄ Beginne mit den Gl√ºcksrad-Spins...")
        for i in range(spins):
            current_spin = i + 1; time.sleep(spin_send_delay)
            spin_command = "%xt%EmpireEx_2%lws%1%{\"LWET\":1}%"
            try: ws.send(spin_command)
            except Exception as send_err: log(f"‚ùå Fehler beim Senden des Spin-Befehls {current_spin}: {send_err}. Breche ab."); traceback.print_exc(); break
            spin_reward_found = False; search_start_time = time.time()
            while time.time() - search_start_time < receive_timeout_per_spin:
                try:
                    remaining_time = max(0.1, receive_timeout_per_spin - (time.time() - search_start_time)); ws.settimeout(remaining_time)
                    msg = ws.recv();
                    if isinstance(msg, bytes): msg = msg.decode("utf-8", errors="ignore")
                    if msg.startswith("%xt%lws%1%0%"): log(f"üéØ [{current_spin}/{spins}] Passende Belohnungsnachricht gefunden!"); parse_reward_message(msg, rewards); spin_reward_found = True; break
                except (websocket.WebSocketTimeoutException, TimeoutError):
                    if not (time.time() - search_start_time < receive_timeout_per_spin): log(f"‚è∞ [{current_spin}/{spins}] Timeout ({receive_timeout_per_spin}s) erreicht beim Warten auf Belohnungsnachricht.")
                    break
                except (websocket.WebSocketConnectionClosedException, BrokenPipeError) as conn_err: log(f"‚ùå [{current_spin}/{spins}] Verbindung geschlossen: {conn_err}. Breche ab."); raise conn_err
                except Exception as recv_err: log(f"‚ö†Ô∏è [{current_spin}/{spins}] Fehler beim Empfangen/Pr√ºfen: {recv_err}"); traceback.print_exc(); break
            if not spin_reward_found: log(f"ü§∑ [{current_spin}/{spins}] Keine passende Belohnungsnachricht gefunden ({receive_timeout_per_spin}s).")
        log("‚úÖ Alle angeforderten Spins wurden versucht.")
    except websocket.WebSocketTimeoutException as e: log(f"‚ùå Connection Timeout ({connect_timeout}s): {e}"); raise ConnectionError("Connection Timeout") from e
    except websocket.WebSocketBadStatusException as e: log(f"‚ùå WebSocket Handshake Failed (Bad Status {e.status_code}): {e.resp_body}"); raise ConnectionError("WebSocket Handshake Failed") from e
    except (websocket.WebSocketConnectionClosedException, BrokenPipeError) as e: log(f"‚ùå WebSocket Connection Closed Unexpectedly: {e}")
    except Exception as e: log(f"‚ùå Schwerwiegender Fehler im spin_lucky_wheel: {e}"); traceback.print_exc(); raise e
    finally:
        if ws and ws.connected: log("üîå Schlie√üe WebSocket-Verbindung."); ws.close()
    log(f"Gesammelte Belohnungen: {dict(rewards)}")
    return dict(rewards)

# --- Bot Instance and Command Definitions ---
bot = SpinBot()

@bot.tree.command(name="spin", description="Startet das Gl√ºcksrad-Drehen f√ºr Goodgame Empire.")
@app_commands.checks.cooldown(1, 60.0, key=lambda i: i.user.id)
async def spin(interaction: discord.Interaction):
    """Slash command handler to initiate the spin process by showing the modal."""
    log(f"Befehl /spin von Benutzer {interaction.user} (ID: {interaction.user.id}) erhalten.")
    await interaction.response.send_modal(SpinModal())

# --- NEW: Test Command ---
@bot.tree.command(name="spintest", description="Zeigt eine Testausgabe aller bekannten Belohnungen mit Emojis an.")
async def spintest(interaction: discord.Interaction):
    """Displays a test embed with sample rewards and emojis."""
    log(f"Befehl /spintest von Benutzer {interaction.user} (ID: {interaction.user.id}) erhalten.")
    await interaction.response.defer(ephemeral=True) # Acknowledge interaction quickly

    # Define sample rewards - include all keys from the map and potential unknown ones
    test_rewards = {
        "Werkzeuge": 30000,
        "Ausr√ºstung/Edelsteine": 30,
        "Konstrukte": 5,
        "Kisten": 120,
        "Dekorationen": 10,
        "Mehrweller": 15,
        "Sceattas": 610,
        "Beatrice-Geschenke": 5,
        "Ulrich-Geschenke": 12,
        "Ludwig-Geschenke": 45,
        "Baumarken": 672,
        "Ausbaumarken": 6592,
        "Rubine": 1000000,
        "Lose": 115,
        "Besch√ºtzer des Nordens": 126000,
        "Schildmaid": 300000,
        "Walk√ºren-Scharfsch√ºtzin": 114000,
        "Walk√ºren-Waldl√§uferin": 197500,
    }

    try:
        # Use the helper function to format the test rewards
        reward_lines = format_rewards_field_value(test_rewards)

        embed_test = discord.Embed(
            title="üß™ SpinBot Testausgabe",
            description="Dies ist eine Vorschau, wie die Belohnungen angezeigt werden:",
            color=discord.Color.blue()
        )
        embed_test.add_field(name="Test-Belohnungen", value=reward_lines, inline=False)
        await interaction.followup.send(embed=embed_test, ephemeral=True)

    except Exception as e:
        log(f"Fehler beim Erstellen der Testausgabe: {e}")
        traceback.print_exc()
        await interaction.followup.send("‚ùå Fehler beim Generieren der Testausgabe.", ephemeral=True)

# --- Error Handler for /spin ---
@spin.error
async def on_spin_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown): await interaction.response.send_message(f"‚è≥ Cooldown aktiv. Bitte warte noch {error.retry_after:.2f} Sekunden.", ephemeral=True)
    else: log(f"Unhandled error in /spin command processing: {error}"); traceback.print_exc(); resp_func = interaction.followup.send if interaction.response.is_done() else interaction.response.send_message; await resp_func("Ein unerwarteter Fehler ist aufgetreten.", ephemeral=True)

# --- Bot Execution ---
if __name__ == "__main__":
    if not TOKEN: print("‚ùå FATAL: DISCORD_TOKEN Umgebungsvariable nicht gesetzt!"); exit(1)
    else:
        log("Starte SpinBot...")
        try: bot.run(TOKEN)
        except discord.LoginFailure: log("‚ùå FATAL: Login zum Discord fehlgeschlagen. Token korrekt?")
        except Exception as e: log(f"‚ùå FATAL: Bot beendet durch Fehler: {e}"); traceback.print_exc()